<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Climate Chart</title>
  <style>
    :root {
      --temp:   #c5352b;
      --precip: #3f7fd8;
      --border: #c8ccd1;
      --page-bg:#f8f9fa;
    }

    body {
      margin: 0;
      padding: 24px;
      background: var(--page-bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   sans-serif;
      color: #111;
    }

    .chart-wrapper {
      width: 650px;
      margin: 0 auto;
      background: #fff;
      box-sizing: border-box;
      padding: 14px 18px 14px;
      position: relative;
    }

    .chart-title {
      font-weight: 700;
      font-size: 20px;
      margin-bottom: 2px;
    }

    .chart-subtitle {
      position: absolute;
      top: 40px;  
      left: 18px;
      right: 18px;
      font-size: 14px;
      color: #555;
      margin: 0;
    }
    
    .data-sources {
      margin-top: 10px;
      padding-top: 6px;
      border-top: 1px solid var(--border);
      font-size: 10.5px;
      line-height: 1.35;
      color: #555;
    }

    .legend {
      font-size: 11px;
    }

    .legend-row {
      display: flex;
      align-items: center;
      margin-bottom: 2px;
    }

    .swatch {
      width: 11px;
      height: 11px;
      border-radius: 2px;
      margin-right: 4px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

</head>
<body>

<div class="chart-wrapper">
  <div class="chart-title" id="title"></div>
  <div class="chart-subtitle" id="subtitle"></div>
  <div id="chart-container"></div>

  <div class="legend">
    <div class="legend-row">
      <div class="swatch" style="background: var(--temp);"></div>
      <span>Average max. and min. temperatures in °F</span>
    </div>
    <div class="legend-row">
      <div class="swatch" style="background: var(--precip);"></div>
      <span>Precipitation totals in inches</span>
    </div>
  </div>
  
  <div class="data-sources">
    <strong>Data sources:</strong>
    Baseline climate conditions are derived from CHELSA v2.1 climatological normals (1981–2010) to maintain methodological consistency with the downscaled projections. Individual station observations may provide higher local accuracy at specific locations.
    Future projections are derived from CHELSA-downscaled UKESM1-0-LL SSP5-8.5 projection normals
    for 2011–2040, 2041–2070 and 2071–2100.
    SSP5-8.5 corresponds to a fossil-fuel–intensive development pathway associated with high greenhouse gas emissions and is widely used as a reference scenario for limited mitigation. UKESM1-0-LL exhibits comparatively high climate sensitivity and strong land–atmosphere coupling, providing an upper-range estimate of potential change. Spatial resolution is 30 arc-seconds (≈1 km at the equator).
    <br><br>
    <strong>Note on Köppen:</strong> Isotherm used to separate temperate (C) and continental (D) climates is 0 °C.
    <br><br>
    <strong>Note on Dickinson:</strong> Dickinson Classification refers to the system described in Dickinson, C. (2026). <i>The Dickinson Climate Classification: A Taxonomic Thermal-Hydrological Partition of Climate State Space</i> [Preprint]. Zenodo. https://doi.org/10.5281/zenodo.18264771
  </div>
</div>

<script>
  var locationName =
  'Los Angeles, California, United States';
  // ============================
  // EARTH ENGINE OUTPUT
  // ============================
  var period = '2071-2100';
  var dickinson= 'Bmz1';
  var dickinson_bordering = 'none';
  var koppen = 'As';
  var koppen_bordering = 'none';
  p_pet = '0.42';
  p_pet_unrounded = '0.415';
  annual_pet_mm = '1359';
  const rawLines = `
    1.0: 79 57 5.6
    2.0: 78 56 4.6
    3.0: 80 58 4.1
    4.0: 85 60 1.3
    5.0: 88 66 0.4
    6.0: 94 71 0.1
    7.0: 100 77 0.0
    8.0: 102 79 0.1
    9.0: 101 80 0.4
    10.0: 95 75 1.3
    11.0: 87 65 1.6
    12.0: 78 55 2.8
    1.0: 26 14 143
    2.0: 25 13 117
    3.0: 27 14 103
    4.0: 29 16 33
    5.0: 31 19 10
    6.0: 34 21 3
    7.0: 38 25 1
    8.0: 39 26 2
    9.0: 38 27 10
    10.0: 35 24 32
    11.0: 31 18 40
    12.0: 26 13 72
  `;
  
  const months = ['J','F','M','A','M','J','J','A','S','O','N','D'];

  const highsF = [], lowsF = [], precipIn = [];
  const highsC = [], lowsC = [], precipMM = [];

  const lines = rawLines.trim().split(/\n+/);

  // first 12 = imperial
  for (let i = 0; i < 12; i++) {
    const nums = lines[i].split(':')[1].trim().split(/\s+/);
    highsF.push(parseFloat(nums[0]));
    lowsF.push(parseFloat(nums[1]));
    precipIn.push(parseFloat(nums[2]));
  }

  // last 12 = metric
  for (let i = 12; i < 24; i++) {
    const nums = lines[i].split(':')[1].trim().split(/\s+/);
    highsC.push(parseFloat(nums[0]));
    lowsC.push(parseFloat(nums[1]));
    precipMM.push(parseFloat(nums[2]));
  }

  
  // ============================
  // Dickinson lookup tables
  // ============================

  const coldMap = {
    X: 'uninhabitable',
    Z: 'hyperequatorial',
    A: 'equatorial',
    B: 'tropical',
    C: 'subtropical',
    D: 'temperate',
    E: 'continental',
    F: 'subarctic',
    G: 'arctic',
    Y: 'superarctic'
  };

  const aridMap = {
    '':  '',
    h: 'humid',
    g: 'semihumid',
    s: 'semiarid',
    d: 'arid',
    m: 'Mediterranean',
    w: 'monsoon'
  };

  const summerMap = {
    H:  'hypercaneal',
    X:  'hyperthermal',
    z2: 'scorching',
    z1: 'very hot',
    a2: 'hot',
    a1: 'warm',
    b2: 'cool',
    b1: 'cold',
    c2: 'very cold',
    c1: 'freezing',
    Y:  'frigid'
  };


  // ============================
  // Dickinson decoder
  // ============================

  function decodeDickinson(code) {
    const cold = code.charAt(0);
    const arid = code.length === 2 ? '' : code.charAt(1);
    const summer = code.slice(arid ? 2 : 1);

    const coldText = coldMap[cold] || '';
    const aridText = aridMap[arid] || '';
    const summerText = summerMap[summer] || '';

    let phrase = coldText;

    if (aridText) phrase += ' ' + aridText;
    if (summerText) phrase += ' with ' + summerText + ' summer';

    return phrase;
  }
  
  function decodeBorderList(str) {
    if (!str || str === 'none') return '';

    const parts = str.trim().split(/\s+/);

    const decoded = parts.map(c =>
      `${c} (${decodeDickinson(c)})`
    );

    if (decoded.length === 1) return decoded[0];

    return decoded.slice(0, -1).join(', ') + ' and ' + decoded.slice(-1);
  }
  
  // ============================
  // Köppen lookup table
  // ============================

  const koppenMap = {

    // Tropical
    Af: 'tropical rainforest',
    Am: 'tropical monsoon',
    Aw: 'tropical savanna',
    As: 'tropical savanna with dry summer',

    // Dry
    BWh: 'hot desert',
    BWk: 'cold desert',
    BSh: 'hot semi-arid',
    BSk: 'cold semi-arid',

    // Temperate
    Cfa: 'humid subtropical',
    Cfb: 'temperate oceanic',
    Cfbh: 'subtropical highland',
    Cfc: 'subpolar oceanic',
    Cfch: 'cold subtropical highland',

    Cwa: 'monsoon-influenced humid subtropical',
    Cwb: 'monsoon-influenced subtropical highland',
    Cwbh: 'monsoon-influenced subtropical highland',
    Cwc: 'monsoon-influenced subpolar oceanic',
    Cwch: 'monsoon-influenced cold subtropical highland',

    Csa: 'hot-summer Mediterranean',
    Csb: 'warm-summer Mediterranean',
    Csc: 'cold-summer Mediterranean',

    // Continental

    Dfa: 'hot-summer humid continental',
    Dfb: 'warm-summer humid continental',
    Dfc: 'subarctic',
    Dfd: 'extremely cold subarctic',
    
    Dwa: 'monsoon-influenced hot-summer humid continental',
    Dwb: 'monsoon-influenced warm-summer humid continental',
    Dwc: 'monsoon-influenced subarctic',
    Dwd: 'monsoon-influenced extremely cold subarctic',

    Dsa: 'Mediterranean-influenced hot-summer humid continental',
    Dsb: 'Mediterranean-influenced warm-summer humid continental',
    Dsc: 'Mediterranean-influenced subarctic',
    Dsd: 'Mediterranean-influenced extremely cold subarctic',

    // Polar
    ET: 'tundra',
    EF: 'ice cap'
  };
  
  const subtropicalHighland = {
    Cfbh: 'Cfb',
    Cfch: 'Cfc',
    Cwbh: 'Cwb',
    Cwch: 'Cwc'
  };

  function stripHighland(code) {
    return subtropicalHighland [code] || code;
  }

  function stripHighlandList(str) {
    if (!str || str === 'none') return str;

    return str
      .trim()
      .split(/\s+/)
      .map(stripHighland)
      .join(' ');
  }

  // ============================
  // Köppen decoder
  // ============================

  function decodeKoppen(code) {
    return koppenMap[code] || '';
  }

  // ============================
  // Decode bordering list
  // ============================

  function decodeKoppenBorderList(str) {
    if (!str || str === 'none') return '';

    const parts = str.trim().split(/\s+/);

    const decoded = parts.map(c =>
      `${c} (${decodeKoppen(c)})`
    );

    if (decoded.length === 1) return decoded[0];

    return decoded.slice(0, -1).join(', ') + ' and ' + decoded.slice(-1);
  }
  
  // ============================
  // UNEP Aridity
  // ============================

  function decodeAI(value) {
    const ai = parseFloat(value);
    if (isNaN(ai)) return '';

    if (ai < 0.04) return 'hyper-arid';
    if (ai < 0.05) return 'hyper-arid bordering on arid';

    if (ai < 0.06) return 'arid bordering on hyper-arid';
    if (ai < 0.19) return 'arid';
    if (ai < 0.20) return 'arid bordering on semiarid';

    if (ai < 0.21) return 'semi-arid bordering on arid';
    if (ai < 0.49) return 'semi-arid';
    if (ai < 0.50) return 'semi-arid bordering on dry subhumid';

    if (ai < 0.51) return 'dry subhumid bordering on semi-arid';
    if (ai < 0.74) return 'dry subhumid';
    if (ai < 0.75) return 'dry subhumid bordering on humid';

    if (ai >= 0.75) return 'humid bordering on semihumid';

    return 'humid';
  }
  
  function formatAI(aiValue, petValue) {

    // if either is N/A → print N/A
    if (aiValue === 'N/A' || petValue === 'N/A') {
      return 'UNEP Aridity Index: <b>N/A</b>';
    }

    const ai  = parseFloat(aiValue);
    const pet = parseFloat(petValue);

    if (isNaN(ai) || isNaN(pet)) {
      return 'UNEP Aridity Index: <b>N/A</b>';
    }

    // ----- cold override -----
    if (pet < 400) {
      return 'UNEP Aridity Index: <b>cold</b> (PET < 400mm)';
    }

    // ----- normal output -----
    return `UNEP Aridity Index: <b>${p_pet}</b> (${decodeAI(ai)})`;
  }

  // ============================
  // Classification outputs
  // ============================
  
  const data = {
  location: locationName,

  code:
    `${period} normals<br><br>` +
    `Dickinson Classification: <b>${dickinson}</b>
    (${decodeDickinson(dickinson)})` +
    (dickinson_bordering !== 'none'
      ? ` (bordering ${decodeBorderList(dickinson_bordering)})`
      : '') +
    `<br><br>` +
    `Köppen Classification: <b>${stripHighland(koppen)}</b>
    (${decodeKoppen(stripHighland(koppen))})` +
    (koppen_bordering !== 'none'
      ? ` (bordering ${decodeKoppenBorderList(stripHighlandList(koppen_bordering))})`
      : '') +
    `<br><br>` +
    formatAI(p_pet_unrounded, annual_pet_mm),

    months,

    // ---- imperial source ----
    highsF,
    lowsF,
    precipIn,

    // ---- metric source ----
    highsC,
    lowsC,
    precipMM,

    // ---- active (what renderer reads) ----
    highs: highsF,
    lows: lowsF,
    precip: precipIn
  };


  document.getElementById('title').textContent = data.location;
  document.getElementById('subtitle').innerHTML = data.code;
  
  let TEMP_MIN;
  let TEMP_MAX;
  let REF_TEMP;
  let PRECIP_MIN;
  let PRECIP_MAX;

  function useFahrenheit() {
    data.highs = data.highsF;
    data.lows = data.lowsF;
    data.precip = data.precipIn;

    TEMP_MIN = -30;
    TEMP_MAX = 125;
    REF_TEMP = 32;

    PRECIP_MIN = 0;
    PRECIP_MAX = 10;
  }

  function useCelsius() {
    data.highs = data.highsC;
    data.lows = data.lowsC;
    data.precip = data.precipMM;

    TEMP_MIN = -34.444;
    TEMP_MAX = 51.666;
    REF_TEMP = 0;

    PRECIP_MIN = 0;
    PRECIP_MAX = 254;
  }

  // ============================
  // DRAW CHART
  // ============================

  const svgWidth = 620;
  const stretchPercip = 0; // CHANGE for extreme percipitation
  const svgHeight = 620 + stretchPercip;

  const margin = { top: 100, right: 20, bottom: 32, left: 20 };

  const tempPanelHeight = 340;
  const gap = 63 + stretchPercip;
  const precipPanelHeight = 55;

  const plotWidth = svgWidth - margin.left - margin.right;
  const tempBaseY = margin.top + tempPanelHeight;
  const precipTopY = tempBaseY + gap;
  const precipBaseY = precipTopY + precipPanelHeight;

  const n = data.months.length;
  const colWidth = plotWidth / n;

  function tempScale(v) {
    return ((v - TEMP_MIN) / (TEMP_MAX - TEMP_MIN)) * (tempPanelHeight * 0.9);
  }

  function precipScale(v) {
    return ((v - PRECIP_MIN) / (PRECIP_MAX - PRECIP_MIN)) * (precipPanelHeight * 0.9);
  }

  function buildChart() {

    let svg = `<svg width="${svgWidth}" height="${svgHeight}">
      <rect width="${svgWidth}" height="${svgHeight}" fill="#ffffff" />
      <g transform="translate(${margin.left},0)">`;

    // ----- THIN DOTTED REFERENCE LINE (32°F / shared Y) -----
    const dottedY = tempBaseY - tempScale(REF_TEMP);

    // draw the dotted line *first* so bars/labels render on top of it
    svg += `
      <line x1="0" y1="${dottedY}"
            x2="${plotWidth}" y2="${dottedY}"
            stroke="#bbb" stroke-width="1"
            stroke-dasharray="4,3" />
    `;

    // ----- Temperature bars (drawn AFTER the line, so they can go over it) -----
    for (let i = 0; i < n; i++) {
      const hi = data.highs[i];
      const lo = data.lows[i];

      const hiH = tempScale(hi);
      const loH = tempScale(lo);

      const barX = colWidth * i + colWidth * 0.28;
      const barW = colWidth * 0.30;

      const hiY = tempBaseY - hiH;
      const loY = tempBaseY - loH;

      svg += `
        <rect x="${barX}" y="${hiY}" width="${barW}" height="${hiH - loH}"
              fill="var(--temp)"></rect>
        <text x="${barX + barW/2}" y="${hiY - 4}"
              text-anchor="middle" font-size="11">${hi}</text>
        <text x="${barX + barW/2}" y="${loY + 12}"
              text-anchor="middle" font-size="10">${lo}</text>
      `;
    }

    // ----- Precipitation bars (also drawn after the line) -----
    for (let i = 0; i < n; i++) {
      const p = data.precip[i];
      const barH = precipScale(p);

      const barX = colWidth * i + colWidth * 0.28;
      const barW = colWidth * 0.30;
      const barY = precipBaseY - barH;

      svg += `
        <rect x="${barX}" y="${barY}" width="${barW}" height="${barH}"
              fill="var(--precip)"></rect>
        <text x="${barX + barW/2}" 
              y="${precipBaseY + 14}" 
              text-anchor="middle"
              font-size="10">${p}</text>
      `;
    }

    // ----- LINE BETWEEN PRECIP & MONTH LABELS -----
    const lowerLineY = precipBaseY + 20;

    svg += `
      <line x1="0" y1="${lowerLineY}"
            x2="${plotWidth}" y2="${lowerLineY}"
            stroke="#000" stroke-width="2" />
    `;

    // ----- Month labels -----
    for (let i = 0; i < n; i++) {
      const x = colWidth * i + colWidth * 0.43;
      const y = lowerLineY + 16;

      svg += `<text x="${x}" y="${y}"
                    text-anchor="middle"
                    font-size="11">${data.months[i]}</text>`;
    }

    svg += `</g></svg>`;

    document.getElementById('chart-container').innerHTML = svg;
  }
  
  useFahrenheit();
  buildChart();
      
  // ============================
  // EXPORT CHART
  // ============================
  
const AUTO_EXPORT = true;

if (AUTO_EXPORT) {
  setTimeout(async () => {

    const el = document.querySelector('.chart-wrapper');

    // ----- filename -----
    let name = data.location.split(',')[0].trim();
    name = name.replace(/\s+/g, '').replace(/[<>:"/\\|?*]+/g, '');

    function periodIndex(p) {
      p = (p || '').replace(/\s+/g,'');
      if (p === "1981-2010") return "1";
      if (p === "2011-2040") return "2";
      if (p === "2041-2070") return "3";
      if (p === "2071-2100") return "4";
      return "X";
    }

    const idx = periodIndex(period);

    async function snap(tag) {
      await new Promise(r => setTimeout(r, 120));

      const canvas = await html2canvas(el, {
        scale: 3,
        backgroundColor: "#ffffff"
      });

      const link = document.createElement('a');
      link.download = `${name}${idx}-${tag}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();

      await new Promise(r => setTimeout(r, 250));
    }

    // -------- F --------
    useFahrenheit();
    buildChart();
    await snap("F");

    // -------- C --------
    useCelsius();
    buildChart();
    await snap("C");

  }, 200);
}

</script>

</body>
</html>