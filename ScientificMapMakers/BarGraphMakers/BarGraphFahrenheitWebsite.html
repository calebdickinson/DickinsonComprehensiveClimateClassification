<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Climate Chart</title>
  <style>
    :root {
      --temp:   #c5352b;
      --precip: #3f7fd8;
      --border: #c8ccd1;
      --page-bg:#f8f9fa;
    }

    body {
      margin: 0;
      padding: 24px;
      background: var(--page-bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   sans-serif;
      color: #111;
    }

    .chart-wrapper {
      width: 650px;
      margin: 0 auto;
      background: #fff;
      box-sizing: border-box;
      padding: 14px 18px 14px;
      position: relative;
    }

    .chart-title {
      font-weight: 700;
      font-size: 20px;
      margin-bottom: 2px;
    }

    .chart-subtitle {
      position: absolute;
      top: 40px;  
      left: 18px;
      right: 18px;
      font-size: 14px;
      color: #555;
      margin: 0;
    }
    
    .data-sources {
      margin-top: 10px;
      padding-top: 6px;
      border-top: 1px solid var(--border);
      font-size: 10.5px;
      line-height: 1.35;
      color: #555;
    }

    .legend {
      font-size: 11px;
    }

    .legend-row {
      display: flex;
      align-items: center;
      margin-bottom: 2px;
    }

    .swatch {
      width: 11px;
      height: 11px;
      border-radius: 2px;
      margin-right: 4px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

</head>
<body>

<div class="chart-wrapper">
  <div class="chart-title" id="title"></div>
  <div class="chart-subtitle" id="subtitle"></div>
  <div id="chart-container"></div>

  <div class="legend">
    <div class="legend-row">
      <div class="swatch" style="background: var(--temp);"></div>
      <span>Average max. and min. temperatures in °F</span>
    </div>
    <div class="legend-row">
      <div class="swatch" style="background: var(--precip);"></div>
      <span>Precipitation totals in inches</span>
    </div>
  </div>
  
  <div class="data-sources">
    <strong>Data sources:</strong>
    Baseline climate conditions are derived from CHELSA v2.1 climatological normals (1981–2010) to ensure methodological consistency with the downscaled projections. Individual station observations may provide higher local accuracy at specific sites.
    Future projections use CHELSA-downscaled UKESM1-0-LL SSP5-8.5 projection normals
    for 2011–2040, 2041–2070, and 2071–2100.
    SSP5-8.5 represents a high-growth, energy-intensive future dominated by fossil fuel use, resulting in very high greenhouse gas emissions—making it a widely used analogue for present-day trajectories under minimal mitigation efforts. UKESM1-0-LL was selected due to its higher climate sensitivity and stronger land–atmosphere coupling, which makes it useful for bounding upper-risk habitability outcomes. This data has a spatial resolution of 30 arc-seconds (≈1 km at the equator).
    <br><br>
    <strong>Note on Köppen:</strong> We use the 0 °C coldest-month isotherm for the Köppen C/D boundary.
    <br><br>
    <strong>Note on Dickinson:</strong> "Dickinson Classification" refers to the system introduced in Dickinson, C. (2026). The Dickinson Climate Classification: A Taxonomic Thermal-Hydrological Partition of Climate State Space [Preprint]. Zenodo. https://doi.org/10.5281/zenodo.18264771
  </div>
</div>

<script>
  // ============================
  // EARTH ENGINE OUTPUT
  // ============================
  var period = '2071-2100';
  var dickinson= 'Bmz1';
  var dickinson_bordering = 'none';
  var koppen = 'As';
  var koppen_bordering = 'none';
  p_pet = '0.42';
  p_pet_unrounded = '0.415';
  annual_pet_mm = '1359';
  const rawLines = `
    1.0: 79 57 5.6
    2.0: 78 56 4.6
    3.0: 80 58 4.1
    4.0: 85 60 1.3
    5.0: 88 66 0.4
    6.0: 94 71 0.1
    7.0: 100 77 0.0
    8.0: 102 79 0.1
    9.0: 101 80 0.4
    10.0: 95 75 1.3
    11.0: 87 65 1.6
    12.0: 78 55 2.8
  `;

  const months = ['J','F','M','A','M','J','J','A','S','O','N','D'];
  const highsF = [], lowsF = [], precipIn = [];

  rawLines.trim().split(/\n+/).forEach(line => {
    const parts = line.split(':');
    if (parts.length < 2) return;

    const nums = parts[1].trim().split(/\s+/);
    highsF.push(parseFloat(nums[0]));
    lowsF.push(parseFloat(nums[1]));
    precipIn.push(parseFloat(nums[2]));
  });
  
  // ============================
  // Dickinson lookup tables
  // ============================

  const coldMap = {
    X: 'uninhabitable',
    Z: 'hyperequatorial',
    A: 'equatorial',
    B: 'tropical',
    C: 'subtropical',
    D: 'temperate',
    E: 'continental',
    F: 'subarctic',
    G: 'arctic',
    Y: 'superarctic'
  };

  const aridMap = {
    '':  '',
    h: 'humid',
    g: 'semihumid',
    s: 'semiarid',
    d: 'arid',
    m: 'Mediterranean',
    w: 'monsoon'
  };

  const summerMap = {
    H:  'hypercaneal',
    X:  'hyperthermal',
    z2: 'scorching',
    z1: 'very hot',
    a2: 'hot',
    a1: 'warm',
    b2: 'cool',
    b1: 'cold',
    c2: 'very cold',
    c1: 'freezing',
    Y:  'frigid'
  };


  // ============================
  // Dickinson decoder
  // ============================

  function decodeDickinson(code) {
    const cold = code.charAt(0);
    const arid = code.length === 2 ? '' : code.charAt(1);
    const summer = code.slice(arid ? 2 : 1);

    const coldText = coldMap[cold] || '';
    const aridText = aridMap[arid] || '';
    const summerText = summerMap[summer] || '';

    let phrase = coldText;

    if (aridText) phrase += ' ' + aridText;
    if (summerText) phrase += ' with ' + summerText + ' summer';

    return phrase;
  }
  
  function decodeBorderList(str) {
    if (!str || str === 'none') return '';

    const parts = str.trim().split(/\s+/);

    const decoded = parts.map(c =>
      `${c} (${decodeDickinson(c)})`
    );

    if (decoded.length === 1) return decoded[0];

    return decoded.slice(0, -1).join(', ') + ' and ' + decoded.slice(-1);
  }
  
  // ============================
  // Köppen lookup table
  // ============================

  const koppenMap = {

    // Tropical
    Af: 'tropical rainforest',
    Am: 'tropical monsoon',
    Aw: 'tropical savanna',
    As: 'tropical savanna with dry summer',

    // Dry
    BWh: 'hot desert',
    BWk: 'cold desert',
    BSh: 'hot semi-arid',
    BSk: 'cold semi-arid',

    // Temperate
    Csa: 'hot-summer Mediterranean',
    Csb: 'warm-summer Mediterranean',
    Csc: 'cold-summer Mediterranean',

    Cwa: 'humid subtropical',
    Cwb: 'subtropical highland (dry winter)',
    Cwc: 'cold subtropical highland (dry winter)',

    Cfa: 'humid subtropical',
    Cfb: 'oceanic',
    Cfc: 'subpolar oceanic',

    // Continental
    Dsa: 'hot-summer continental (dry summer)',
    Dsb: 'warm-summer continental (dry summer)',
    Dsc: 'subarctic (dry summer)',
    Dsd: 'extremely continental (dry summer)',

    Dwa: 'hot-summer continental (dry winter)',
    Dwb: 'warm-summer continental (dry winter)',
    Dwc: 'subarctic (dry winter)',
    Dwd: 'extremely continental (dry winter)',

    Dfa: 'hot-summer continental',
    Dfb: 'warm-summer continental',
    Dfc: 'subarctic',
    Dfd: 'extremely continental',

    // Polar
    ET: 'tundra',
    EF: 'ice cap'
  };

  // ============================
  // Köppen decoder
  // ============================

  function decodeKoppen(code) {
    return koppenMap[code] || '';
  }

  // ============================
  // Decode bordering list
  // ============================

  function decodeKoppenBorderList(str) {
    if (!str || str === 'none') return '';

    const parts = str.trim().split(/\s+/);

    const decoded = parts.map(c =>
      `${c} (${decodeKoppen(c)})`
    );

    if (decoded.length === 1) return decoded[0];

    return decoded.slice(0, -1).join(', ') + ' and ' + decoded.slice(-1);
  }
  
  // ============================
  // UNEP Aridity
  // ============================

  function decodeAI(value) {
    const ai = parseFloat(value);
    if (isNaN(ai)) return '';

    if (ai < 0.04) return 'hyper-arid';
    if (ai < 0.05) return 'hyper-arid bordering on arid';

    if (ai < 0.06) return 'arid bordering on hyper-arid';
    if (ai < 0.19) return 'arid';
    if (ai < 0.20) return 'arid bordering on semiarid';

    if (ai < 0.21) return 'semi-arid bordering on arid';
    if (ai < 0.49) return 'semi-arid';
    if (ai < 0.50) return 'semi-arid bordering on dry subhumid';

    if (ai < 0.51) return 'dry subhumid bordering on semi-arid';
    if (ai < 0.74) return 'dry subhumid';
    if (ai < 0.75) return 'dry subhumid bordering on humid';

    if (ai >= 0.75) return 'humid bordering on semihumid';

    return 'humid';
  }
  
    function formatAI(aiValue, petValue) {

      // if either is N/A → print N/A
      if (aiValue === 'N/A' || petValue === 'N/A') {
        return 'UNEP Aridity Index: <b>N/A</b>';
      }

      const ai  = parseFloat(aiValue);
      const pet = parseFloat(petValue);

      if (isNaN(ai) || isNaN(pet)) {
        return 'UNEP Aridity Index: <b>N/A</b>';
      }

      // ----- cold override -----
      if (pet < 400) {
        return 'UNEP Aridity Index: <b>cold</b> (PET < 400mm)';
      }

      // ----- normal output -----
      return `UNEP Aridity Index: <b>${p_pet}</b> (${decodeAI(ai)})`;
    }

  // ============================
  // Classification outputs
  // ============================
  
  const data = {
  location: 'Los Angeles (city center), California, United States',
  code:
    `${period} normals<br><br>` +
    `Dickinson Classification: <b>${dickinson}</b>
    (${decodeDickinson(dickinson)})` +
    (dickinson_bordering !== 'none'
      ? ` (bordering ${decodeBorderList(dickinson_bordering)})`
      : '') +
    `<br><br>` +
    `Köppen Classification: <b>${koppen}</b>
    (${decodeKoppen(koppen)})` +
	(koppen_bordering !== 'none'
      ? ` (bordering ${decodeKoppenBorderList(koppen_bordering)})`
      : '') +
    `<br><br>` +
    formatAI(p_pet_unrounded, annual_pet_mm),
    months,
    highsF,
    lowsF,
    precipIn
  };

  document.getElementById('title').textContent = data.location;
  document.getElementById('subtitle').innerHTML = data.code;

  // ============================
  // DRAW CHART
  // ============================

  const svgWidth = 620;
  const stretchPercip = 0; // CHANGE for extreme percipitation
  const svgHeight = 620 + stretchPercip;

  const margin = { top: 100, right: 20, bottom: 32, left: 20 };

  const tempPanelHeight = 340;
  const gap = 63 + stretchPercip;
  const precipPanelHeight = 55;

  const plotWidth = svgWidth - margin.left - margin.right;
  const tempBaseY = margin.top + tempPanelHeight;
  const precipTopY = tempBaseY + gap;
  const precipBaseY = precipTopY + precipPanelHeight;

  const n = data.months.length;
  const colWidth = plotWidth / n;

  const TEMP_MIN_FIXED = -30;
  const TEMP_MAX_FIXED = 125;
  const TEMP_RANGE_FIXED = TEMP_MAX_FIXED - TEMP_MIN_FIXED;

  function tempScale(v) {
    return ((v - TEMP_MIN_FIXED) / TEMP_RANGE_FIXED) * (tempPanelHeight * 0.9);
  }

  const PRECIP_MIN_FIXED = 0;
  const PRECIP_MAX_FIXED = 10;
  const PRECIP_RANGE_FIXED = PRECIP_MAX_FIXED - PRECIP_MIN_FIXED;

  function precipScale(v) {
    return ((v - PRECIP_MIN_FIXED) / PRECIP_RANGE_FIXED) * (precipPanelHeight * 0.9);
  }

  let svg = `<svg width="${svgWidth}" height="${svgHeight}">
    <rect width="${svgWidth}" height="${svgHeight}" fill="#ffffff" />
    <g transform="translate(${margin.left},0)">`;

  // ----- THIN DOTTED REFERENCE LINE (32°F / shared Y) -----
  const refTemp = 32;
  const dottedY = tempBaseY - tempScale(refTemp);

  // draw the dotted line *first* so bars/labels render on top of it
  svg += `
    <line x1="0" y1="${dottedY}"
          x2="${plotWidth}" y2="${dottedY}"
          stroke="#bbb" stroke-width="1"
          stroke-dasharray="4,3" />
  `;

  // ----- Temperature bars (drawn AFTER the line, so they can go over it) -----
  for (let i = 0; i < n; i++) {
    const hi = data.highsF[i];
    const lo = data.lowsF[i];

    const hiH = tempScale(hi);
    const loH = tempScale(lo);

    const barX = colWidth * i + colWidth * 0.28;
    const barW = colWidth * 0.30;

    const hiY = tempBaseY - hiH;
    const loY = tempBaseY - loH;

    svg += `
      <rect x="${barX}" y="${hiY}" width="${barW}" height="${hiH - loH}"
            fill="var(--temp)"></rect>
      <text x="${barX + barW/2}" y="${hiY - 4}"
            text-anchor="middle" font-size="11">${hi}</text>
      <text x="${barX + barW/2}" y="${loY + 12}"
            text-anchor="middle" font-size="10">${lo}</text>
    `;
  }

  // ----- Precipitation bars (also drawn after the line) -----
  for (let i = 0; i < n; i++) {
    const p = data.precipIn[i];
    const barH = precipScale(p);

    const barX = colWidth * i + colWidth * 0.28;
    const barW = colWidth * 0.30;
    const barY = precipBaseY - barH;

    svg += `
      <rect x="${barX}" y="${barY}" width="${barW}" height="${barH}"
            fill="var(--precip)"></rect>
      <text x="${barX + barW/2}" 
            y="${precipBaseY + 14}" 
            text-anchor="middle"
            font-size="10">${p}</text>
    `;
  }

  // ----- LINE BETWEEN PRECIP & MONTH LABELS -----
  const lowerLineY = precipBaseY + 20;

  svg += `
    <line x1="0" y1="${lowerLineY}"
          x2="${plotWidth}" y2="${lowerLineY}"
          stroke="#000" stroke-width="2" />
  `;

  // ----- Month labels -----
  for (let i = 0; i < n; i++) {
    const x = colWidth * i + colWidth * 0.43;
    const y = lowerLineY + 16;

    svg += `<text x="${x}" y="${y}"
                  text-anchor="middle"
                  font-size="11">${data.months[i]}</text>`;
  }

  svg += `</g></svg>`;

  document.getElementById('chart-container').innerHTML = svg;
  
  // ============================
  // EXPORT CHART
  // ============================
  
const AUTO_EXPORT = false; // Change to true to export png

if (AUTO_EXPORT) {
  setTimeout(() => {
    const el = document.querySelector('.chart-wrapper');

    // ---------- LOCATION ----------
    let name = data.location.split(',')[0].trim();

    // remove ALL spaces
    name = name.replace(/\s+/g, '');

    // remove illegal filename characters
    name = name.replace(/[<>:"/\\|?*]+/g, '');

    // ---------- PERIOD SUFFIX ----------
    const plainCode = data.code.replace(/<[^>]*>/g, '');

    let suffix = "";

    if (plainCode.startsWith("2071 - 2100")) suffix = "4-F";
    else if (plainCode.startsWith("2041 - 2070")) suffix = "3-F";
    else if (plainCode.startsWith("2011 - 2040")) suffix = "2-F";
    else if (plainCode.startsWith("1981 - 2010")) suffix = "1-F";

    const fileName = `${name}${suffix}.png`;

    // ---------- EXPORT ----------
    html2canvas(el, {
      scale: 3,
      backgroundColor: "#ffffff"
    }).then(canvas => {
      const link = document.createElement('a');
      link.download = fileName;
      link.href = canvas.toDataURL("image/png");
      link.click();
    });

  }, 100);
}

</script>

</body>
</html>